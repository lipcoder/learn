好，我们就按你刚才那个例子的输出顺序，把**程序从启动到 main()**经历的每一步拆开讲清楚。你看到的顺序之所以会那样，完全是 Go 的初始化规则在起作用。

我先把“规则”用一句话定下来，然后逐行对照输出。

---

## Go 初始化总规则（你只要记住这 3 条）

1. **先初始化依赖包，再初始化当前包**（按 import 依赖图，从叶子到根）
2. **一个包内部：先初始化所有包级变量，再执行所有 `init()`**
3. **所有包都初始化完后，才进入 `main.main()`**

---

## 你看到的输出（回忆）

```
config: init Port (package var initializer)
config: init()
logger: init Prefix (package var initializer)
logger: init() (can use config.Port = 8080 )
main: init()
main: main()
[port=8080] hello
```

下面我们解释：为什么每一行会在那个时刻出现。

---

## 第 0 步：程序启动，构建依赖图

`main` 里 `import "initdemo/logger"`
`logger` 里 `import "initdemo/config"`

所以依赖链是：

**main → logger → config**

Go 运行时必须保证：`config` 完成后才能轮到 `logger`，`logger` 完成后才能轮到 `main`。

---

## 第 1 步：初始化 `config` 包的“包级变量”

`config` 里有：

```go
var Port = func() int {
    fmt.Println("config: init Port (package var initializer)")
    ...
}()
```

这是一个**包级变量初始化表达式**，而且是“函数立即执行”。所以初始化 `Port` 的时候会立刻打印：

✅ 输出第 1 行：

```
config: init Port (package var initializer)
```

**为什么它一定先于 `config.init()`？**
因为规则 2：包内顺序是**先变量，后 init**。

---

## 第 2 步：执行 `config` 包的 `init()`

`config` 的包级变量都初始化完后，Go 才会调用该包的 `init()`：

```go
func init() {
    fmt.Println("config: init()")
}
```

✅ 输出第 2 行：

```
config: init()
```

到这里 `config` 包初始化完成。

---

## 第 3 步：轮到 `logger` 包，先初始化它的包级变量

`logger` 的包级变量：

```go
var Prefix = func() string {
    fmt.Println("logger: init Prefix (package var initializer)")
    return fmt.Sprintf("[port=%d] ", config.Port)
}()
```

开始初始化 `Prefix` 时，会打印：

✅ 输出第 3 行：

```
logger: init Prefix (package var initializer)
```

**关键点：此时访问 `config.Port` 安全吗？**
安全。因为规则 1：`logger` 初始化前，`config` 已经初始化完了，所以 `config.Port` 已经是最终值（8080 或 9090）。

---

## 第 4 步：执行 `logger` 包的 `init()`

变量初始化完，进入：

```go
func init() {
    fmt.Println("logger: init() (can use config.Port =", config.Port, ")")
}
```

✅ 输出第 4 行：

```
logger: init() (can use config.Port = 8080 )
```

到这里 `logger` 包也初始化完成。

---

## 第 5 步：回到 `main` 包，执行 `main` 的 `init()`

`main` 包里有：

```go
func init() {
    fmt.Println("main: init()")
}
```

✅ 输出第 5 行：

```
main: init()
```

（注意：`main` 包也遵守同样规则：如果它有包级变量，会先初始化变量，再 init；这里只是没写包级变量。）

---

## 第 6 步：进入真正的入口 `main.main()`

所有包都初始化完了，Go 才调用：

```go
func main() {
    fmt.Println("main: main()")
    logger.Println("hello")
}
```

✅ 输出第 6 行：

```
main: main()
```

---

## 第 7 步：运行你显式调用的代码

`logger.Println("hello")`：

```go
func Println(msg string) {
    fmt.Println(Prefix + msg)
}
```

此时 `Prefix` 在第 3 步就初始化好了，比如 `"[port=8080] "`
所以最终打印：

✅ 输出第 7 行：

```
[port=8080] hello
```

---

## 一句话总结“为什么是这个顺序”

* 因为 **config 是 logger 的依赖**，所以先初始化 config
* 因为 **包内先初始化变量再执行 init**，所以 Port 的打印在 config.init 之前
* 所有包 init 完才会进 main.main，因此 main.init 在 main.main 之前

---

如果你想更“直观地验证”，我也可以把例子扩展成：同一个包分成 `a.go / b.go` 两个文件，让你看到“文件名排序导致的初始化顺序”，这也是这一节常让人迷惑的点。
